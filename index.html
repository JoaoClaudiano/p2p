<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rede SOS H√≠brida</title>
    <style>
        /* (Estilos otimizados e responsivos - semelhantes ao anterior) */
        :root { --color-emergency: #c62828; --color-dark: #121212; }
        * { box-sizing: border-box; }
        body { font-family: sans-serif; background: var(--color-dark); color: white; margin: 0; padding: 20px; }
        header { text-align: center; margin-bottom: 2rem; }
        h1 { color: var(--color-emergency); }
        .mode-selector { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 2rem; }
        .mode-card { background: #1e1e1e; border-radius: 12px; padding: 1.5rem; text-align: center; cursor: pointer; border: 2px solid transparent; transition: all 0.3s; }
        .mode-card:hover { border-color: var(--color-emergency); background: #252525; }
        .card-icon { font-size: 2.5rem; margin-bottom: 10px; }
        .chat-interface { display: none; margin-top: 2rem; }
        #chat-messages { height: 300px; overflow-y: auto; border: 1px solid #444; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; background: #0a0a0a; }
        .message { margin-bottom: 10px; padding: 8px 12px; border-radius: 18px; max-width: 80%; }
        .message.self { background: var(--color-emergency); margin-left: auto; }
        .message.remote { background: #333; }
        .message.system { background: #004d40; font-style: italic; text-align: center; }
        #msg-input { width: 100%; padding: 12px; border-radius: 24px; border: 1px solid #555; background: #2a2a2a; color: white; }
        .input-group { display: flex; gap: 10px; margin-top: 1rem; }
        button { background: var(--color-emergency); color: white; border: none; padding: 12px 24px; border-radius: 24px; font-weight: bold; cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #connection-status { margin-top: 1rem; padding: 10px; border-radius: 8px; background: #1b5e20; display: none; }
        #back-button { display: none; margin-top: 1rem; background: #555; }
    </style>
</head>
<body>
    <header>
        <h1>üÜò Rede de Emerg√™ncia H√≠brida</h1>
        <p>Escolha como conectar-se a outros sobreviventes</p>
    </header>

    <div class="mode-selector" id="modeSelector">
        <div class="mode-card" data-mode="bluetooth">
            <div class="card-icon">üì±</div>
            <h3>Modo Bluetooth</h3>
            <p>Conex√£o direta e privada com um dispositivo pr√≥ximo. Ideal para pares.</p>
        </div>
        <div class="mode-card" data-mode="network">
            <div class="card-icon">üåê</div>
            <h3>Modo Rede Local</h3>
            <p>Conecte-se a um "Host" na mesma rede Wi-Fi. Permite grupo sem internet.</p>
            <input type="text" id="roomCodeInput" placeholder="C√≥digo da Sala (opcional)" style="margin-top:10px; padding:8px; width:100%; border-radius:8px; display:none;">
        </div>
    </div>

    <div id="chat-interface" class="chat-interface">
        <div id="connection-status"></div>
        <div id="chat-messages"></div>
        <div class="input-group">
            <input type="text" id="msg-input" placeholder="Digite sua mensagem de emerg√™ncia..." disabled>
            <button id="send-button" disabled>Enviar</button>
        </div>
        <button id="back-button">‚¨Ö Voltar para Sele√ß√£o</button>
    </div>

    <script>
        // ========== CONFIGURA√á√ïES E VARI√ÅVEIS ==========
        const modeSelector = document.getElementById('modeSelector');
        const chatInterface = document.getElementById('chat-interface');
        const chatMessages = document.getElementById('chat-messages');
        const msgInput = document.getElementById('msg-input');
        const sendButton = document.getElementById('send-button');
        const backButton = document.getElementById('back-button');
        const connectionStatus = document.getElementById('connection-status');
        const roomCodeInput = document.getElementById('roomCodeInput');

        let currentMode = null;
        let localPeerConnection = null; // Para WebRTC
        let dataChannel = null; // Canal para troca de mensagens (Rede)
        let websocket = null; // Conex√£o com servidor de sinaliza√ß√£o
        // Vari√°veis Bluetooth (do c√≥digo anterior)
        let bluetoothDevice = null;
        let chatCharacteristic = null;
        const BT_SERVICE_UUID = '0000ffe0-0000-1000-8000-00805f9b34fb';
        const BT_CHAR_UUID = '0000ffe1-0000-1000-8000-00805f9b34fb';

        // ========== SELE√á√ÉO DO MODO ==========
        modeSelector.addEventListener('click', (e) => {
            const card = e.target.closest('.mode-card');
            if (!card) return;
            
            currentMode = card.dataset.mode;
            modeSelector.style.display = 'none';
            chatInterface.style.display = 'block';
            backButton.style.display = 'inline-block';
            
            if (currentMode === 'bluetooth') {
                initBluetoothMode();
            } else if (currentMode === 'network') {
                // Pede o IP do host e c√≥digo da sala
                const hostIP = prompt("Digite o endere√ßo IP do HOST (ex: 192.168.1.10):", "localhost");
                const roomCode = roomCodeInput.value || prompt("Digite o c√≥digo da sala (deixe em branco para criar):", "") || "sos-room-default";
                if (hostIP) {
                    initNetworkMode(hostIP, roomCode);
                } else {
                    alert("IP do host √© obrigat√≥rio!");
                    goBack();
                }
            }
        });

        // ========== MODO BLUETOOTH ==========
        async function initBluetoothMode() {
            updateStatus("Modo Bluetooth. Clique em 'Conectar' no pr√≥ximo passo.", "info");
            showSystemMessage("Pronto para conex√£o Bluetooth direta.");
            
            // Adiciona um bot√£o de conectar Bluetooth espec√≠fico
            const connectBtn = document.createElement('button');
            connectBtn.id = 'bt-connect-btn';
            connectBtn.textContent = 'üîó Conectar via Bluetooth';
            connectBtn.style.marginBottom = '1rem';
            chatMessages.parentNode.insertBefore(connectBtn, chatMessages);
            
            connectBtn.onclick = async () => {
                try {
                    updateStatus("Buscando dispositivos Bluetooth...", "warning");
                    bluetoothDevice = await navigator.bluetooth.requestDevice({
                        filters: [{ namePrefix: 'SOS' }, { services: [BT_SERVICE_UUID] }],
                        optionalServices: [BT_SERVICE_UUID]
                    });
                    const server = await bluetoothDevice.gatt.connect();
                    const service = await server.getPrimaryService(BT_SERVICE_UUID);
                    chatCharacteristic = await service.getCharacteristic(BT_CHAR_UUID);
                    await chatCharacteristic.startNotifications();
                    chatCharacteristic.addEventListener('characteristicvaluechanged', (e) => {
                        const decoder = new TextDecoder();
                        const msg = decoder.decode(e.target.value);
                        addMessage(msg, 'remote', 'Dispositivo');
                    });
                    updateStatus(`Conectado a: ${bluetoothDevice.name || 'Dispositivo'}`, "success");
                    showSystemMessage("Conex√£o Bluetooth estabelecida!");
                    connectBtn.style.display = 'none';
                    msgInput.disabled = false;
                    sendButton.disabled = false;
                    sendButton.onclick = sendMessageBluetooth;
                } catch (err) {
                    console.error("Erro Bluetooth:", err);
                    updateStatus(`Erro: ${err.message}`, "error");
                }
            };
        }

        async function sendMessageBluetooth() {
            const text = msgInput.value.trim();
            if (!text || !chatCharacteristic) return;
            try {
                const encoder = new TextEncoder();
                await chatCharacteristic.writeValue(encoder.encode(text));
                addMessage(text, 'self', 'Voc√™');
                msgInput.value = '';
            } catch (err) {
                alert("Falha ao enviar via Bluetooth.");
            }
        }

        // ========== MODO REDE LOCAL (WebRTC) ==========
        async function initNetworkMode(hostIP, roomCode) {
            updateStatus(`Conectando √† sala: ${roomCode}...`, "info");
            showSystemMessage(`Modo Rede Local. Conectando ao host: ${hostIP}`);
            
            // Configura√ß√£o WebRTC
            const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
            localPeerConnection = new RTCPeerConnection(config);
            
            // Cria canal de dados para trocar mensagens de texto
            dataChannel = localPeerConnection.createDataChannel('chat');
            setupDataChannel(dataChannel);
            
            // Lida com candidatos ICE (para encontrar caminho de conex√£o)
            localPeerConnection.onicecandidate = ({ candidate }) => {
                if (candidate && websocket.readyState === WebSocket.OPEN) {
                    websocket.send(JSON.stringify({ type: 'ice-candidate', candidate, room: roomCode }));
                }
            };
            
            // Lida com dados recebidos de outro par
            localPeerConnection.ondatachannel = (e) => {
                const channel = e.channel;
                setupDataChannel(channel);
            };
            
            // Conecta ao servidor de sinaliza√ß√£o do Host (WebSocket)
            websocket = new WebSocket(`ws://${hostIP}:8080`);
            websocket.onopen = () => {
                websocket.send(JSON.stringify({ type: 'join', room: roomCode }));
                updateStatus(`Conectado √† sala "${roomCode}". Aguardando pares...`, "success");
            };
            
            websocket.onmessage = async (e) => {
                const signal = JSON.parse(e.data);
                if (signal.type === 'offer') {
                    // Recebe uma oferta de conex√£o de outro par
                    await localPeerConnection.setRemoteDescription(new RTCSessionDescription(signal.offer));
                    const answer = await localPeerConnection.createAnswer();
                    await localPeerConnection.setLocalDescription(answer);
                    websocket.send(JSON.stringify({ type: 'answer', answer, room: roomCode }));
                } else if (signal.type === 'answer') {
                    // Recebe uma resposta √† nossa oferta
                    await localPeerConnection.setRemoteDescription(new RTCSessionDescription(signal.answer));
                } else if (signal.type === 'ice-candidate') {
                    // Adiciona candidato ICE para estabelecer conex√£o
                    try {
                        await localPeerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
                    } catch (err) { /* Ignora erros em candidatos duplicados */ }
                } else if (signal.type === 'user-count') {
                    updateStatus(`Usu√°rios na sala: ${signal.count}`, "info");
                }
            };
            
            // Se criarmos a oferta (seremos o "iniciador" na sala)
            setTimeout(() => {
                if (localPeerConnection.signalingState === 'stable') {
                    initiateWebRTCConnection(roomCode);
                }
            }, 1000);
            
            msgInput.disabled = false;
            sendButton.disabled = false;
            sendButton.onclick = sendMessageNetwork;
        }

        function setupDataChannel(channel) {
            channel.onopen = () => {
                showSystemMessage("Conex√£o direta (P2P) estabelecida!");
                updateStatus("‚úÖ Conectado via Rede P2P", "success");
            };
            channel.onmessage = (e) => {
                addMessage(e.data, 'remote', 'Remoto');
            };
            channel.onclose = () => {
                showSystemMessage("Conex√£o P2P fechada.");
            };
            dataChannel = channel; // Atualiza a refer√™ncia global
        }

        async function initiateWebRTCConnection(roomCode) {
            // Cria e envia uma oferta de conex√£o para outros na sala
            const offer = await localPeerConnection.createOffer();
            await localPeerConnection.setLocalDescription(offer);
            websocket.send(JSON.stringify({ type: 'offer', offer, room: roomCode }));
        }

        function sendMessageNetwork() {
            const text = msgInput.value.trim();
            if (!text || !dataChannel || dataChannel.readyState !== 'open') {
                alert("Canal de dados n√£o est√° aberto.");
                return;
            }
            dataChannel.send(text);
            addMessage(text, 'self', 'Voc√™');
            msgInput.value = '';
        }

        // ========== FUN√á√ïES DE UTILIDADE (UI) ==========
        function addMessage(text, type, sender) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.innerHTML = `<strong>${sender}:</strong> ${text}`;
            chatMessages.appendChild(msgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showSystemMessage(text) {
            addMessage(text, 'system', 'Sistema');
        }

        function updateStatus(text, type = 'info') {
            connectionStatus.textContent = text;
            connectionStatus.style.display = 'block';
            connectionStatus.style.background = 
                type === 'success' ? '#1b5e20' : 
                type === 'warning' ? '#f57f17' : 
                type === 'error' ? '#b71c1c' : '#0d47a1';
        }

        function goBack() {
            // Limpa conex√µes
            if (websocket) websocket.close();
            if (localPeerConnection) localPeerConnection.close();
            if (bluetoothDevice && bluetoothDevice.gatt.connected) bluetoothDevice.gatt.disconnect();
            
            // Reseta UI
            currentMode = null;
            modeSelector.style.display = 'grid';
            chatInterface.style.display = 'none';
            backButton.style.display = 'none';
            connectionStatus.style.display = 'none';
            chatMessages.innerHTML = '';
            msgInput.value = '';
            msgInput.disabled = true;
            sendButton.disabled = true;
            
            // Remove bot√£o Bluetooth se existir
            const btBtn = document.getElementById('bt-connect-btn');
            if (btBtn) btBtn.remove();
        }

        backButton.onclick = goBack;

        // Permite enviar mensagem com Enter
        msgInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !sendButton.disabled) sendButton.click();
        });

        // Mostra campo de c√≥digo quando rede √© selecionada
        document.querySelector('[data-mode="network"]').addEventListener('mouseenter', () => {
            roomCodeInput.style.display = 'block';
        });
    </script>
</body>
</html>